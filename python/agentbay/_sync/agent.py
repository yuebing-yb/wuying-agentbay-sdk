import time
# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

import json
from typing import TYPE_CHECKING

from .._common.exceptions import AgentBayError, AgentError
from .._common.logger import get_logger
from .._common.models.agent import (
    ExecutionResult,
    QueryResult,
    InitializationResult,
    AgentOptions,
)
from .base_service import BaseService

if TYPE_CHECKING:
    from .session import Session

# Initialize logger for this module
_logger = get_logger("agent")


class Agent(BaseService):
    """
    An Agent to manipulate applications to complete specific tasks.
    """

    def __init__(self, session: "Session"):
        super().__init__(session)
        self.browser = self.Browser(session)
        self.computer = self.Computer(session)
        self.mobile = self.Mobile(session)

    def _handle_error(self, e):
        """
        Convert AgentBayError to AgentError for compatibility.

        Args:
            e (Exception): The exception to convert.

        Returns:
            AgentError: The converted exception.
        """
        if isinstance(e, AgentError):
            return e
        if isinstance(e, AgentBayError):
            return AgentError(str(e))
        return e

    class _BaseTaskAgent(BaseService):
        """Base class for task execution agents."""

        def __init__(self, session: "Session", tool_prefix: str):
            """
            Initialize base task agent.

            Args:
                session: The session object.
                tool_prefix: Prefix for MCP tool names (e.g., "flux" or "browser_use").
            """
            super().__init__(session)
            self.tool_prefix = tool_prefix

        def _get_tool_name(self, action: str) -> str:
            """Get the full MCP tool name based on prefix and action."""
            tool_map = {
                "execute": "execute_task",
                "get_status": "get_task_status",
                "terminate": "terminate_task",
            }
            base_name = tool_map.get(action, action)
            if self.tool_prefix:
                return f"{self.tool_prefix}_{base_name}"
            return base_name

        def _handle_error(self, e):
            """
            Convert AgentBayError to AgentError for compatibility.

            Args:
                e (Exception): The exception to convert.

            Returns:
                AgentError: The converted exception.
            """
            if isinstance(e, AgentError):
                return e
            if isinstance(e, AgentBayError):
                return AgentError(str(e))
            return e

        def execute_task(self, task: str) -> ExecutionResult:
            """
            Execute a task in human language without waiting for completion (non-blocking).

            This is a fire-and-return interface that immediately provides a task ID.
            Call get_task_status to check the task status. You can control the timeout
            of the task execution in your own code by setting the frequency of calling
            get_task_status and the max_try_times.

            Args:
                task: Task description in human language.

            Returns:
                ExecutionResult: Result object containing success status, task ID,
                    task status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.computer.execute_task("Open Chrome browser")
                print(f"Task ID: {result.task_id}, Status: {result.task_status}")
                status = session.agent.computer.get_task_status(result.task_id)
                print(f"Task status: {status.task_status}")
                session.delete()
                ```
            """
            try:
                args = {"task": task}
                result = self.session.call_mcp_tool(
                    self._get_tool_name("execute"), args
                )
                if result.success:
                    content = json.loads(result.data)
                    task_id = content.get("taskId") or content.get("task_id", "")
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=True,
                        error_message="",
                        task_id=task_id,
                        task_status="running",
                    )
                else:
                    _logger.error("task execute failed")
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=False,
                        error_message=result.error_message or "Failed to execute task",
                        task_status="failed",
                        task_id="",
                    )
            except AgentError as e:
                handled_error = self._handle_error(e)
                return ExecutionResult(
                    request_id="", success=False, error_message=str(handled_error)
                )
            except Exception as e:
                handled_error = self._handle_error(AgentBayError(str(e)))
                return ExecutionResult(
                    request_id="",
                    success=False,
                    error_message=f"Failed to execute: {handled_error}",
                    task_status="failed",
                    task_id="",
                )

        def execute_task_and_wait(
            self, task: str, max_try_times: int
        ) -> ExecutionResult:
            """
            Execute a specific task described in human language synchronously.

            This is a synchronous interface that blocks until the task is completed or
            an error occurs, or timeout happens. The default polling interval is 3 seconds,
            so set a proper max_try_times according to your task complexity.

            Args:
                task: Task description in human language.
                max_try_times: Maximum number of retries.

            Returns:
                ExecutionResult: Result object containing success status, task ID,
                    task status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.computer.execute_task_and_wait("Open Chrome browser", max_try_times=20)
                print(f"Task result: {result.task_result}")
                session.delete()
                ```
            """
            try:
                args = {"task": task}
                result = self.session.call_mcp_tool(
                    self._get_tool_name("execute"), args
                )
                if result.success:
                    content = json.loads(result.data)
                    task_id = content.get("taskId") or content.get("task_id", "")
                    tried_time: int = 0
                    while tried_time < max_try_times:
                        query = self.get_task_status(task_id)
                        if query.task_status == "completed":
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=True,
                                error_message="",
                                task_id=task_id,
                                task_status=query.task_status,
                                task_result=query.task_product,
                            )
                        elif query.task_status == "failed":
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=False,
                                error_message="Failed to execute task.",
                                task_id=task_id,
                                task_status=query.task_status,
                            )
                        elif query.task_status == "cancelled":
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=False,
                                error_message="Task was cancelled.",
                                task_id=task_id,
                                task_status=query.task_status,
                            )
                        elif query.task_status == "unsupported":
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=False,
                                error_message="Unsupported task.",
                                task_id=task_id,
                                task_status=query.task_status,
                            )
                        _logger.info(
                            f"‚è≥ Task {task_id} running üöÄ: {query.task_action}."
                        )
                        # keep waiting unit timeout if the status is running
                        # task_status {running, completed, failed, cancelled}
                        time.sleep(3)
                        tried_time += 1
                    _logger.warning("‚ö†Ô∏è task execution timeout!")
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=False,
                        error_message="Task timeout.",
                        task_id=task_id,
                        task_status="failed",
                        task_result="Task timeout.",
                    )
                else:
                    _logger.error("‚ùå Task execution failed")
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=False,
                        error_message=result.error_message or "Failed to execute task",
                        task_status="failed",
                        task_id="",
                        task_result="Task Failed",
                    )
            except AgentError as e:
                handled_error = self._handle_error(e)
                return ExecutionResult(
                    request_id="",
                    success=False,
                    error_message=str(handled_error),
                    task_status="failed",
                    task_id="",
                    task_result="Task Failed",
                )
            except Exception as e:
                handled_error = self._handle_error(AgentBayError(str(e)))
                return ExecutionResult(
                    request_id="",
                    success=False,
                    error_message=f"Failed to execute: {handled_error}",
                    task_status="failed",
                    task_id="",
                    task_result="Task Failed",
                )

        def get_task_status(self, task_id: str) -> QueryResult:
            """
            Get the status of the task with the given task ID.

            Args:
                task_id: The ID of the task to query.

            Returns:
                QueryResult: Result object containing success status, task status,
                    task action, task product, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.computer.execute_task("Query the weather in Shanghai with Baidu")
                status = session.agent.computer.get_task_status(result.task_id)
                print(f"Status: {status.task_status}, Action: {status.task_action}")
                session.delete()
                ```
            """
            try:
                args = {"task_id": task_id}
                result = self.session.call_mcp_tool(
                    self._get_tool_name("get_status"), args
                )
                if result.success:
                    content = json.loads(result.data)
                    # Support both taskId (camelCase) and task_id (snake_case)
                    content_task_id = content.get("taskId") or content.get("task_id", task_id)
                    # Mobile Agent returns "result", other agents return "product"
                    # Support both for compatibility, prefer "result"
                    task_product = content.get("result") or content.get("product", "")
                    # Extract stream and error fields
                    stream = content.get("stream", [])
                    if not isinstance(stream, list):
                        stream = []
                    error = content.get("error", "")
                    return QueryResult(
                        success=True,
                        request_id=result.request_id,
                        error_message="",
                        task_id=content_task_id,
                        task_status=content.get("status", "completed"),
                        task_action=content.get("action", ""),
                        task_product=task_product,
                        stream=stream,
                        error=error,
                    )
                else:
                    return QueryResult(
                        request_id=result.request_id,
                        success=False,
                        error_message=result.error_message
                        or "Failed to get task status",
                        task_id=task_id,
                        task_status="failed",
                    )
            except AgentError as e:
                handled_error = self._handle_error(e)
                return QueryResult(
                    request_id="",
                    success=False,
                    error_message=str(handled_error),
                    task_id=task_id,
                    task_status="failed",
                )
            except Exception as e:
                handled_error = self._handle_error(AgentBayError(str(e)))
                return QueryResult(
                    request_id="",
                    success=False,
                    error_message=f"Failed to get task status: {handled_error}",
                    task_id=task_id,
                    task_status="failed",
                )

        def terminate_task(self, task_id: str) -> ExecutionResult:
            """
            Terminate a task with a specified task ID.

            Args:
                task_id: The ID of the running task to terminate.

            Returns:
                ExecutionResult: Result object containing success status, task ID,
                    task status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.computer.execute_task("Query the weather in Shanghai with Baidu")
                terminate_result = session.agent.computer.terminate_task(result.task_id)
                print(f"Terminated: {terminate_result.success}")
                session.delete()
                ```
            """
            _logger.info("Terminating task")
            try:
                args = {"task_id": task_id}
                result = self.session.call_mcp_tool(
                    self._get_tool_name("terminate"), args
                )
                if result.success:
                    content = json.loads(result.data)
                    # Support both taskId (camelCase) and task_id (snake_case)
                    task_id = content.get("taskId") or content.get("task_id", task_id)
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=True,
                        error_message="",
                        task_id=task_id,
                        task_status=content.get("status", "cancelling"),
                    )
                else:
                    content = json.loads(result.data) if result.data else {}
                    return ExecutionResult(
                        request_id=result.request_id,
                        success=False,
                        error_message=result.error_message
                        or "Failed to terminate task",
                        task_id=task_id,
                        task_status="failed",
                    )
            except AgentError as e:
                handled_error = self._handle_error(e)
                return ExecutionResult(
                    request_id=result.request_id if "result" in locals() else "",
                    success=False,
                    error_message=str(handled_error),
                    task_id=task_id,
                    task_status="failed",
                )
            except Exception as e:
                handled_error = self._handle_error(AgentBayError(str(e)))
                return ExecutionResult(
                    request_id="",
                    success=False,
                    error_message=f"Failed to terminate: {handled_error}",
                    task_id=task_id,
                    task_status="failed",
                )

    class Computer(_BaseTaskAgent):
        """
        An Agent to perform tasks on the computer.
        """

        def __init__(self, session: "Session"):
            super().__init__(session, tool_prefix="flux")

    class Browser(_BaseTaskAgent):
        """
        An Agent(‚ö†Ô∏è Still in BETA) to perform tasks on the browser
        """

        def __init__(self, session: "Session"):
            super().__init__(session, tool_prefix="browser_use")

        def initialize(
            self, options: AgentOptions = None
        ) -> InitializationResult:
            """
            Initialize the browser agent with options.

            Args:
                options: options for the agent.

            Returns:
                InitializationResult: Result object containing success status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                options:AgentOptions = AgentOptions(use_vision=False, output_schema="")
                initialize_result = session.agent.browser.initialize(options)
                print(f"Initialized: {initialize_result.success}")
                session.delete()
                ```
            """
            _logger.info("Initialize Browser Use Agent...")
            try:
                args = {"use_vision": False, "output_schema": {}}
                if options is not None:
                    args = {
                        "use_vision": options.use_vision,
                        "output_schema": options.output_schema,
                    }

                result = self.session.call_mcp_tool(
                    "browser_use_initialize", args
                )
                if result.success:
                    return InitializationResult(
                        request_id=result.request_id, success=True, error_message=""
                    )
                else:
                    return InitializationResult(
                        request_id=result.request_id,
                        success=False,
                        error_message="Failed to initialize browser use agent",
                    )
            except AgentError as e:
                _logger.error(f"Failed to initialize: {e}")
                handled_error = self._handle_error(e)
                return InitializationResult(
                    request_id=result.request_id if "result" in locals() else "",
                    success=False,
                    error_message=str(handled_error),
                )
            except Exception as e:
                _logger.error(f"Failed to initialize: {e}")
                handled_error = self._handle_error(AgentBayError(str(e)))
                return InitializationResult(
                    request_id="",
                    success=False,
                    error_message=f"Failed to initialize: {handled_error}",
                )

    class Mobile(_BaseTaskAgent):
        """
        An Agent to perform tasks on mobile devices.
        """

        def __init__(self, session: "Session"):
            super().__init__(session, tool_prefix="")

        def execute_task(
            self,
            task: str,
            max_steps: int = 50,
            max_step_retries: int = 3,
        ) -> ExecutionResult:
            """
            Execute a task in human language without waiting for completion
            (non-blocking).

            This is a fire-and-return interface that immediately provides a task ID.
            Call get_task_status to check the task status. You can control the timeout
            of the task execution in your own code by setting the frequency of calling
            get_task_status.

            Args:
                task: Task description in human language.
                max_steps: Maximum number of steps (clicks/swipes/etc.) allowed.
                    Used to prevent infinite loops or excessive resource consumption.
                    Default is 50.
                max_step_retries: Maximum retry times for MCP tool call failures
                    at SDK level. Used to retry when call_mcp_tool fails
                    (e.g., network errors, timeouts). Default is 3.

            Returns:
                ExecutionResult: Result object containing success status, task ID,
                    task status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.mobile.execute_task(
                    "Open WeChat app", max_steps=100, max_step_retries=5
                )
                print(f"Task ID: {result.task_id}, Status: {result.task_status}")
                status = session.agent.mobile.get_task_status(result.task_id)
                print(f"Task status: {status.task_status}")
                session.delete()
                ```
            """
            args = {
                "task": task,
                "max_steps": max_steps,
            }

            last_error = None
            last_request_id = ""

            for attempt in range(max_step_retries):
                try:
                    result = self.session.call_mcp_tool(
                        self._get_tool_name("execute"), args
                    )
                    last_request_id = result.request_id

                    if result.success:
                        content = json.loads(result.data)
                        task_id = content.get("taskId") or content.get("task_id", "")
                        return ExecutionResult(
                            request_id=result.request_id,
                            success=True,
                            error_message="",
                            task_id=task_id,
                            task_status="running",
                        )
                    else:
                        last_error = (
                            result.error_message or "Failed to execute task"
                        )
                        if attempt < max_step_retries - 1:
                            _logger.warning(
                                f"Attempt {attempt + 1}/{max_step_retries} "
                                "failed, retrying..."
                            )
                            time.sleep(1)
                            continue
                        else:
                            _logger.error(
                                "task execute failed after all retries"
                            )
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=False,
                                error_message=last_error,
                                task_status="failed",
                                task_id="",
                            )
                except AgentError as e:
                    handled_error = self._handle_error(e)
                    last_error = str(handled_error)
                    if attempt < max_step_retries - 1:
                        _logger.warning(
                            f"Attempt {attempt + 1}/{max_step_retries} "
                            "raised exception, retrying..."
                        )
                        time.sleep(1)
                        continue
                    else:
                        return ExecutionResult(
                            request_id=last_request_id,
                            success=False,
                            error_message=str(handled_error),
                            task_status="failed",
                            task_id="",
                        )
                except Exception as e:
                    handled_error = self._handle_error(AgentBayError(str(e)))
                    last_error = f"Failed to execute: {handled_error}"
                    if attempt < max_step_retries - 1:
                        _logger.warning(
                            f"Attempt {attempt + 1}/{max_step_retries} "
                            "raised exception, retrying..."
                        )
                        time.sleep(1)
                        continue
                    else:
                        return ExecutionResult(
                            request_id=last_request_id,
                            success=False,
                            error_message=(
                                f"Failed after {max_step_retries} attempts: "
                                f"{handled_error}"
                            ),
                            task_status="failed",
                            task_id="",
                        )

            return ExecutionResult(
                request_id=last_request_id,
                success=False,
                error_message=(
                    f"Failed after {max_step_retries} attempts: "
                    f"{last_error or 'Unknown error'}"
                ),
                task_status="failed",
                task_id="",
            )

        def execute_task_and_wait(
            self,
            task: str,
            max_steps: int = 50,
            max_step_retries: int = 3,
            max_try_times: int = 300,
        ) -> ExecutionResult:
            """
            Execute a specific task described in human language synchronously.

            This is a synchronous interface that blocks until the task is
            completed or an error occurs, or timeout happens. The default
            polling interval is 3 seconds, so set a proper max_try_times
            according to your task complexity.

            Args:
                task: Task description in human language.
                max_steps: Maximum number of steps (clicks/swipes/etc.) allowed.
                    Used to prevent infinite loops or excessive resource consumption.
                    Default is 50.
                max_step_retries: Maximum retry times for MCP tool call
                    failures at SDK level. Used to retry when call_mcp_tool
                    fails (e.g., network errors, timeouts). Default is 3.
                max_try_times: Maximum number of polling attempts (each 3 seconds).
                    Used to control how long to wait for task completion.
                    Default is 300 (about 15 minutes).

            Returns:
                ExecutionResult: Result object containing success status, task ID,
                    task status, and error message if any.

            Example:
                ```python
                session_result = agent_bay.create()
                session = session_result.session
                result = session.agent.mobile.execute_task_and_wait(
                    "Open WeChat app and send a message",
                    max_steps=100,
                    max_step_retries=3,
                    max_try_times=200
                )
                print(f"Task result: {result.task_result}")
                session.delete()
                ```
            """
            args = {
                "task": task,
                "max_steps": max_steps,
            }

            task_id = None
            last_error = None
            last_request_id = ""

            for attempt in range(max_step_retries):
                try:
                    result = self.session.call_mcp_tool(
                        self._get_tool_name("execute"), args
                    )
                    last_request_id = result.request_id

                    if result.success:
                        content = json.loads(result.data)
                        task_id = content.get("taskId") or content.get("task_id", "")
                        break
                    else:
                        last_error = (
                            result.error_message or "Failed to execute task"
                        )
                        if attempt < max_step_retries - 1:
                            _logger.warning(
                                f"Attempt {attempt + 1}/{max_step_retries} "
                                "failed, retrying..."
                            )
                            time.sleep(1)
                            continue
                        else:
                            _logger.error(
                                "Task execution failed after all retries"
                            )
                            return ExecutionResult(
                                request_id=result.request_id,
                                success=False,
                                error_message=last_error,
                                task_status="failed",
                                task_id="",
                                task_result="Task Failed",
                            )
                except AgentError as e:
                    handled_error = self._handle_error(e)
                    last_error = str(handled_error)
                    if attempt < max_step_retries - 1:
                        _logger.warning(
                            f"Attempt {attempt + 1}/{max_step_retries} "
                            "raised exception, retrying..."
                        )
                        time.sleep(1)
                        continue
                    else:
                        return ExecutionResult(
                            request_id=last_request_id,
                            success=False,
                            error_message=str(handled_error),
                            task_status="failed",
                            task_id="",
                            task_result="Task Failed",
                        )
                except Exception as e:
                    handled_error = self._handle_error(AgentBayError(str(e)))
                    last_error = f"Failed to execute: {handled_error}"
                    if attempt < max_step_retries - 1:
                        _logger.warning(
                            f"Attempt {attempt + 1}/{max_step_retries} "
                            "raised exception, retrying..."
                        )
                        time.sleep(1)
                        continue
                    else:
                        return ExecutionResult(
                            request_id=last_request_id,
                            success=False,
                            error_message=(
                                f"Failed after {max_step_retries} attempts: "
                                f"{handled_error}"
                            ),
                            task_status="failed",
                            task_id="",
                            task_result="Task Failed",
                        )

            if not task_id:
                return ExecutionResult(
                    request_id=last_request_id,
                    success=False,
                    error_message=(
                        f"Failed to get task_id after {max_step_retries} "
                        f"attempts: {last_error or 'Unknown error'}"
                    ),
                    task_status="failed",
                    task_id="",
                    task_result="Task Failed",
                )

            tried_time: int = 0
            last_stream_index = -1  # Track processed stream fragments
            while tried_time < max_try_times:
                query = self.get_task_status(task_id)
                
                # Process new stream fragments for real-time output
                if query.stream and len(query.stream) > last_stream_index + 1:
                    new_streams = query.stream[last_stream_index + 1:]
                    for stream_item in new_streams:
                        if isinstance(stream_item, dict):
                            content = stream_item.get("content", "")
                            reasoning = stream_item.get("reasoning", "")
                            if content:
                                _logger.info(f"üìù {content}")
                            if reasoning:
                                _logger.debug(f"üí≠ {reasoning}")
                    last_stream_index = len(query.stream) - 1
                
                # Check for error field
                if query.error:
                    _logger.warning(f"‚ö†Ô∏è Task error: {query.error}")
                
                if query.task_status == "completed":
                    return ExecutionResult(
                        request_id=last_request_id,
                        success=True,
                        error_message="",
                        task_id=task_id,
                        task_status=query.task_status,
                        task_result=query.task_product,
                    )
                elif query.task_status == "failed":
                    error_msg = query.error or "Failed to execute task."
                    return ExecutionResult(
                        request_id=last_request_id,
                        success=False,
                        error_message=error_msg,
                        task_id=task_id,
                        task_status=query.task_status,
                    )
                elif query.task_status == "cancelled":
                    error_msg = query.error or "Task was cancelled."
                    return ExecutionResult(
                        request_id=last_request_id,
                        success=False,
                        error_message=error_msg,
                        task_id=task_id,
                        task_status=query.task_status,
                    )
                elif query.task_status == "unsupported":
                    error_msg = query.error or "Unsupported task."
                    return ExecutionResult(
                        request_id=last_request_id,
                        success=False,
                        error_message=error_msg,
                        task_id=task_id,
                        task_status=query.task_status,
                    )
                _logger.info(
                    f"‚è≥ Task {task_id} running üöÄ: {query.task_action}."
                )
                time.sleep(3)
                tried_time += 1

            _logger.warning("‚ö†Ô∏è task execution timeout!")
            return ExecutionResult(
                request_id=last_request_id,
                success=False,
                error_message="Task timeout.",
                task_id=task_id,
                task_status="failed",
                task_result="Task timeout.",
            )
