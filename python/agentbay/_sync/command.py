# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

import json
from typing import Any, Dict, Optional

from .._common.exceptions import AgentBayError, CommandError
from .._common.logger import get_logger
from .._common.models.command import CommandResult
from .._common.models.response import ApiResponse
from .base_service import BaseService

# Initialize _logger for this module
_logger = get_logger("command")


class Command(BaseService):
    """
    Handles command execution operations in the AgentBay cloud environment.
    """

    def execute_command(
        self,
        command: str,
        timeout_ms: int = 60000,
        cwd: Optional[str] = None,
        envs: Optional[Dict[str, str]] = None,
    ) -> CommandResult:
        """
        Execute a shell command with optional working directory and environment variables.

        Executes a shell command in the session environment with configurable timeout,
        working directory, and environment variables. The command runs with session
        user permissions in a Linux shell environment.

        Args:
            command: The shell command to execute
            timeout_ms: Timeout in milliseconds (default: 60000ms/60s). Maximum allowed
                timeout is 50000ms (50s). If a larger value is provided, it will be
                automatically limited to 50000ms
            cwd: The working directory for command execution. If not specified,
                the command runs in the default session directory
            envs: Environment variables as a dictionary of key-value pairs.
                These variables are set for the command execution only

        Returns:
            CommandResult: Result object containing:
                - success: Whether the command executed successfully (exit_code == 0)
                - output: Command output for backward compatibility (stdout + stderr)
                - exit_code: The exit code of the command execution (0 for success)
                - stdout: Standard output from the command execution
                - stderr: Standard error from the command execution
                - trace_id: Trace ID for error tracking (only present when exit_code != 0)
                - request_id: Unique identifier for this API request
                - error_message: Error description if execution failed

        Raises:
            CommandError: If the command execution fails due to system errors

        Example:
            session = agent_bay.create().session
            result = session.command.execute_command("echo 'Hello, World!'")
            print(result.output)
            print(result.exit_code)
            session.delete()

        Example:
            result = session.command.execute_command(
                "pwd",
                timeout_ms=5000,
                cwd="/tmp",
                envs={"TEST_VAR": "test_value"}
            )
            print(result.stdout)
            session.delete()
        """
        try:
            # Limit timeout to maximum 50s (50000ms) as per SDK constraints
            MAX_TIMEOUT_MS = 50000
            if timeout_ms > MAX_TIMEOUT_MS:
                _logger.warning(
                    f"Timeout {timeout_ms}ms exceeds maximum allowed {MAX_TIMEOUT_MS}ms. "
                    f"Limiting to {MAX_TIMEOUT_MS}ms."
                )
                timeout_ms = MAX_TIMEOUT_MS

            # Build request arguments
            args = {"command": command, "timeout_ms": timeout_ms}
            if cwd is not None:
                args["cwd"] = cwd
            if envs is not None:
                args["envs"] = envs

            result = self.session.call_mcp_tool("shell", args)
            _logger.debug(f"Execute command response: {result}")

            if result.success:
                # Try to parse the new JSON format response
                try:
                    # Parse JSON string from result.data
                    if isinstance(result.data, str):
                        data_json = json.loads(result.data)
                    else:
                        data_json = result.data

                    # Extract fields from new format
                    stdout = data_json.get("stdout", "")
                    stderr = data_json.get("stderr", "")
                    error_code = data_json.get("errorCode", 0)
                    trace_id = data_json.get("traceId", "")

                    # Determine success based on errorCode (0 means success)
                    success = error_code == 0

                    # For backward compatibility, output should be stdout + stderr
                    output = stdout + stderr

                    return CommandResult(
                        request_id=result.request_id,
                        success=success,
                        output=output,
                        exit_code=error_code,
                        stdout=stdout,
                        stderr=stderr,
                        trace_id=trace_id,
                    )
                except (json.JSONDecodeError, TypeError, AttributeError) as e:
                    # Fallback to old format if JSON parsing fails
                    _logger.debug(f"Failed to parse JSON response, using old format: {e}")
                    return CommandResult(
                        request_id=result.request_id,
                        success=True,
                        output=result.data if isinstance(result.data, str) else str(result.data),
                    )
            else:
                return CommandResult(
                    request_id=result.request_id,
                    success=False,
                    error_message=result.error_message or "Failed to execute command",
                )
        except Exception as e:
            return CommandResult(
                request_id="",
                success=False,
                error_message=f"Failed to execute command: {e}",
            )
