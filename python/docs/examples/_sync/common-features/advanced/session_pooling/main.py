import time
# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated from the _async directory.

"""
Example demonstrating session pooling with AgentBay SDK.

This example shows how to:
- Create a pool of reusable sessions
- Acquire and release sessions from the pool
- Manage pool size and limits
- Handle session lifecycle in a pool
- Implement connection pooling patterns
"""

import os
from typing import Optional, List
from dataclasses import dataclass
from datetime import datetime

from agentbay import AgentBay
from agentbay import CreateSessionParams
import threading


@dataclass
class PooledSession:
    """Wrapper for a pooled session."""
    session: any
    created_at: datetime
    last_used: datetime
    in_use: bool = False


class SessionPool:
    """Pool manager for AgentBay sessions."""
    
    def __init__(
        self,
        agent_bay: AgentBay,
        min_size: int = 2,
        max_size: int = 5,
        image_id: str = "linux_latest"
    ):
        self.agent_bay = agent_bay
        self.min_size = min_size
        self.max_size = max_size
        self.image_id = image_id
        self.pool: List[PooledSession] = []
        self.lock = threading.Lock()
    
    def initialize(self):
        """Initialize the pool with minimum number of sessions."""
        print(f"\nüèä Initializing session pool (min={self.min_size}, max={self.max_size})...")
        
        for i in range(self.min_size):
            session = self._create_session()
            if session:
                print(f"  ‚úÖ Created session {i+1}/{self.min_size}")
    
    def _create_session(self) -> Optional[any]:
        """Create a new session."""
        try:
            params = CreateSessionParams(image_id=self.image_id)
            result = self.agent_bay.create(params)
            
            if result.success and result.session:
                pooled_session = PooledSession(
                    session=result.session,
                    created_at=datetime.now(),
                    last_used=datetime.now(),
                    in_use=False
                )
                self.pool.append(pooled_session)
                return result.session
        except Exception as e:
            print(f"  ‚ùå Failed to create session: {e}")
        
        return None
    
    def acquire(self) -> Optional[any]:
        """Acquire a session from the pool."""
        with self.lock:
            # Find available session
            for pooled_session in self.pool:
                if not pooled_session.in_use:
                    pooled_session.in_use = True
                    pooled_session.last_used = datetime.now()
                    print(f"  ‚úÖ Acquired session from pool: {pooled_session.session.session_id}")
                    return pooled_session.session
            
            # No available session, create new one if under max_size
            if len(self.pool) < self.max_size:
                print(f"  üìà Pool at capacity, creating new session...")
                session = self._create_session()
                if session:
                    # Mark as in use
                    for pooled_session in self.pool:
                        if pooled_session.session == session:
                            pooled_session.in_use = True
                            return session
            
            print(f"  ‚ö†Ô∏è  Pool exhausted, waiting for available session...")
            return None
    
    def release(self, session: any):
        """Release a session back to the pool."""
        with self.lock:
            for pooled_session in self.pool:
                if pooled_session.session == session:
                    pooled_session.in_use = False
                    print(f"  ‚úÖ Released session back to pool: {session.session_id}")
                    return
    
    def cleanup(self):
        """Clean up all sessions in the pool."""
        print(f"\nüßπ Cleaning up session pool ({len(self.pool)} sessions)...")
        
        for pooled_session in self.pool:
            try:
                result = self.agent_bay.delete(pooled_session.session)
                if result.success:
                    print(f"  ‚úÖ Deleted session: {pooled_session.session.session_id}")
            except Exception as e:
                print(f"  ‚ùå Failed to delete session: {e}")
        
        self.pool.clear()
    
    def get_stats(self) -> dict:
        """Get pool statistics."""
        total = len(self.pool)
        in_use = sum(1 for ps in self.pool if ps.in_use)
        available = total - in_use
        
        return {
            "total_sessions": total,
            "in_use": in_use,
            "available": available,
            "utilization": (in_use / total * 100) if total > 0 else 0
        }
    
    def print_stats(self):
        """Print pool statistics."""
        stats = self.get_stats()
        print(f"\nüìä Pool Statistics:")
        print(f"   Total Sessions: {stats['total_sessions']}")
        print(f"   In Use: {stats['in_use']}")
        print(f"   Available: {stats['available']}")
        print(f"   Utilization: {stats['utilization']:.1f}%")


def worker_task(pool: SessionPool, task_id: int, num_operations: int):
    """Worker task that uses sessions from the pool."""
    print(f"\nüîß Worker {task_id} starting ({num_operations} operations)...")
    
    for i in range(num_operations):
        session = pool.acquire()
        
        if session:
            try:
                # Perform some work with the session
                command = f"echo 'Worker {task_id}, Operation {i+1}'"
                result = session.command.execute_command(command)
                
                if result.success:
                    print(f"  ‚úÖ Worker {task_id}, Op {i+1}: {result.output.strip()}")
                
                # Simulate some work
                time.sleep(0.5)
                
            finally:
                pool.release(session)
        else:
            print(f"  ‚ö†Ô∏è  Worker {task_id}, Op {i+1}: No session available")
            time.sleep(1)
    
    print(f"  ‚úÖ Worker {task_id} completed")


def main():
    """Main function demonstrating session pooling."""
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        print("‚ùå Error: AGENTBAY_API_KEY environment variable not set")
        return
    
    agent_bay = AgentBay(api_key=api_key)
    pool = None
    
    try:
        print("=" * 60)
        print("Session Pooling Example")
        print("=" * 60)
        
        # Create and initialize pool
        pool = SessionPool(
            agent_bay=agent_bay,
            min_size=2,
            max_size=4,
            image_id="linux_latest"
        )
        
        pool.initialize()
        pool.print_stats()
        
        # Example 1: Sequential session usage
        print("\n" + "=" * 60)
        print("Example 1: Sequential Session Usage")
        print("=" * 60)
        
        for i in range(3):
            session = pool.acquire()
            if session:
                result = session.command.execute_command(f"echo 'Sequential operation {i+1}'")
                if result.success:
                    print(f"‚úÖ Operation {i+1}: {result.output.strip()}")
                pool.release(session)
        
        pool.print_stats()
        
        # Example 2: Concurrent workers using the pool
        print("\n" + "=" * 60)
        print("Example 2: Concurrent Workers")
        print("=" * 60)
        
        workers = [
            worker_task(pool, 1, 3),
            worker_task(pool, 2, 3),
            worker_task(pool, 3, 3),
        ]
        
        [task for task in workers]
        
        pool.print_stats()
        
        print("\n‚úÖ Session pooling examples completed")
        
    except Exception as e:
        print(f"\n‚ùå Error: {e}")
        
    finally:
        if pool:
            pool.cleanup()


if __name__ == "__main__":
    main()

