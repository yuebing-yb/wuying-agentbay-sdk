import time
# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for Agent functionality."""

import os

import pytest
import pytest

from agentbay import AgentBay
from agentbay import get_logger
from agentbay import CreateSessionParams
from pydantic import BaseModel

from dotenv import load_dotenv

logger = get_logger("agentbay-integration-test")
load_dotenv()


@pytest.fixture(scope="module")
def agent_bay():
    """Create an AgentBay instance."""
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture(scope="module")
def computer_agent_session(agent_bay):
    """Create a session for agent testing."""
    # Ensure a delay to avoid session creation conflicts
    time.sleep(3)
    params = CreateSessionParams(
        image_id="windows_latest",
    )
    session_result = agent_bay.create(params)
    if not session_result.success or not session_result.session:
        pytest.skip("Failed to create session")

    session = session_result.session
    yield session

    # Clean up session
    try:
        session.delete()
    except Exception as e:
        logger.info(f"Warning: Error deleting session: {e}")


@pytest.fixture(scope="module")
def browser_agent_session(agent_bay):
    """Create a session for agent testing."""
    # Ensure a delay to avoid session creation conflicts
    time.sleep(3)
    params = CreateSessionParams(
        image_id="browser_latest",
    )
    session_result = agent_bay.create(params)
    if not session_result.success or not session_result.session:
        pytest.skip("Failed to create session")

    session = session_result.session
    yield session

    # Clean up session
    try:
        session.delete()
    except Exception as e:
        logger.info(f"Warning: Error deleting session: {e}")


@pytest.fixture(scope="module")
def mobile_agent_session(agent_bay):
    """Create a session for mobile agent testing."""
    # Ensure a delay to avoid session creation conflicts
    time.sleep(3)
    params = CreateSessionParams(
        image_id="imgc-0aae4rgien5oudgb6",
    )
    session_result = agent_bay.create(params)
    if not session_result.success or not session_result.session:
        pytest.skip("Failed to create session")

    session = session_result.session
    yield session

    # Clean up session
    try:
        session.delete()
    except Exception as e:
        logger.info(f"Warning: Error deleting session: {e}")


@pytest.mark.sync
def test_computer_execute_task_and_wait_success(computer_agent_session):
    """Test executing a flux task successfully."""
    agent = computer_agent_session.agent

    task = "create a folder named 'agentbay' in C:\\Window\\Temp"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    logger.info("ðŸš€ task of creating folders")
    result = agent.computer.execute_task_and_wait(task, timeout)
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    logger.info(f"âœ… result {result.task_result}")


@pytest.mark.sync
def test_computer_execute_task_success(computer_agent_session):
    """Test executing a flux task successfully."""
    agent = computer_agent_session.agent

    task = "create a folder named 'agentbay' in C:\\Window\\Temp"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    max_poll_attempts = timeout // 3
    logger.info("ðŸš€ async task of creating folders")
    result = agent.computer.execute_task(task)
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    retry_times: int = 0
    query_result = None
    while retry_times < max_poll_attempts:
        query_result = agent.computer.get_task_status(result.task_id)
        assert result.success
        logger.info(
            f"â³ Task {query_result.task_id} running ðŸš€: {query_result.task_action}."
        )
        if query_result.task_status == "finished":
            break
        retry_times += 1
        time.sleep(3)
    # Verify the final task status
    assert retry_times < max_poll_attempts
    logger.info(f"âœ… result {query_result.task_product}")

class OutputSchema(BaseModel):
    """Schema for query test."""

    ListedDate: str

@pytest.mark.sync
def test_browser_execute_task_and_wait_success(browser_agent_session):
    """Test executing a flux task successfully."""
    agent = browser_agent_session.agent

    task = "Navigate to baidu.com and Query the date when Alibaba listed in the U.S"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    logger.info("ðŸš€ task of Query the date when Alibaba listed in the U.S")

    result = agent.browser.execute_task_and_wait(
        task, timeout, use_vision=False, output_schema=OutputSchema
    )
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    logger.info(f"âœ… result {result.task_result}")


class WeatherSchema(BaseModel):
    """Schema for weather query test."""

    Weather: str
    City: str

@pytest.mark.sync
def test_browser_execute_task_success(browser_agent_session):
    """Test executing a flux task successfully."""
    agent = browser_agent_session.agent

    task = "Navigate to baidu.com and Query the weather in Shanghai"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    max_poll_attempts = timeout // 3
    logger.info("ðŸš€ async task Query the weather in Shanghai.")
    result = agent.browser.execute_task(
        task, use_vision=False, output_schema=WeatherSchema
    )
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    retry_times: int = 0
    query_result = None
    while retry_times < max_poll_attempts:
        query_result = agent.browser.get_task_status(result.task_id)
        assert result.success
        logger.info(
            f"â³ Task {query_result.task_id} running ðŸš€: {query_result.task_action}."
        )
        if query_result.task_status == "finished":
            break
        retry_times += 1
        time.sleep(3)
    # Verify the final task status
    assert retry_times < max_poll_attempts
    logger.info(f"âœ… result {query_result.task_product}")


@pytest.mark.sync
def test_mobile_execute_task_and_wait_success(mobile_agent_session):
    """Test executing a mobile task successfully."""
    agent = mobile_agent_session.agent

    task = "Open WeChat app"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    logger.info("ðŸš€ task of opening WeChat app")
    result = agent.mobile.execute_task_and_wait(
        task, max_steps=50, timeout=timeout
    )
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    logger.info(f"âœ… result {result.task_result}")


@pytest.mark.sync
def test_mobile_execute_task_success(mobile_agent_session):
    """Test executing a mobile task successfully."""
    agent = mobile_agent_session.agent

    task = "Open WeChat app"
    timeout = os.environ.get("AGENT_TASK_TIMEOUT")
    if not timeout:
        timeout = 180
    timeout = int(timeout)
    max_poll_attempts = timeout // 3
    logger.info("ðŸš€ async task of opening WeChat app")
    result = agent.mobile.execute_task(
        task, max_steps=50
    )
    assert result.success
    assert result.request_id != ""
    assert result.error_message == ""
    retry_times: int = 0
    query_result = None
    while retry_times < max_poll_attempts:
        query_result = agent.mobile.get_task_status(result.task_id)
        assert result.success
        logger.info(
            f"â³ Task {query_result.task_id} running ðŸš€: {query_result.task_action}."
        )
        if query_result.task_status == "completed":
            break
        retry_times += 1
        time.sleep(3)
    # Verify the final task status
    assert retry_times < max_poll_attempts
    logger.info(f"âœ… result {query_result.task_product}")
