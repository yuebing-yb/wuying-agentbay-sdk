# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests demonstrating get_status usage for Session status checking."""

import os
import time
import unittest
from uuid import uuid4

import pytest
from dotenv import load_dotenv

from agentbay import AgentBay, CreateSessionParams
from agentbay import AgentBayError
from agentbay import SessionPauseResult, SessionResumeResult
from agentbay import Config

def get_test_api_key():
    """Get API key for testing."""
    return os.environ.get("AGENTBAY_API_KEY")

def get_test_endpoint():
    """Get endpoint for testing."""
    return os.environ.get("AGENTBAY_ENDPOINT")

class TestGetStatusUsage(unittest.TestCase):
    """Integration tests demonstrating get_status method usage."""

    @classmethod
    def setUpClass(cls):
        """Set up test fixtures for the entire test class."""
        # Load environment variables from .env file
        load_dotenv()

        # Get API Key and Endpoint
        api_key = get_test_api_key()
        if not api_key:
            raise unittest.SkipTest("AGENTBAY_API_KEY environment variable not set")

        endpoint = get_test_endpoint()

        # Initialize AgentBay client
        if endpoint:
            config = Config(endpoint=endpoint, timeout_ms=60000)
            cls.agent_bay = AgentBay(api_key=api_key, cfg=config)
            print(f"Using endpoint: {endpoint}")
        else:
            cls.agent_bay = AgentBay(api_key=api_key)
            print("Using default endpoint")

    def setUp(self):
        """Set up test fixtures for each test method."""
        self.test_sessions = []  # Track sessions for cleanup in each test

    def tearDown(self):
        """Clean up test sessions after each test method."""
        print("\nCleaning up test sessions for this test...")
        for session in self.test_sessions:
            try:
                # Try to resume session first in case it's paused
                try:
                    session.resume()
                    print(f"  ✓ Resumed session: {session.session_id}")
                except Exception as resume_error:
                    print(f"  ⚠ Could not resume session {session.session_id}: {resume_error}")
                
                # Delete session
                result = self.agent_bay.delete(session)
                if result.success:
                    print(f"  ✓ Deleted session: {session.session_id}")
                else:
                    print(f"  ✗ Failed to delete session: {session.session_id}")
            except Exception as e:
                print(f"  ✗ Error deleting session {session.session_id}: {e}")
        # Clear the list for next test
        self.test_sessions = []

    def _create_test_session(self):
        """Helper method to create a test session."""
        session_name = f"test-get-status-{uuid4().hex[:8]}"
        print(f"\nCreating test session: {session_name}")

        # Create session
        params = CreateSessionParams(
            labels={"project": "get-status-demo", "environment": "testing"},
        )
        result = self.agent_bay.create(params)
        self.assertTrue(
            result.success, f"Failed to create session: {result.error_message}"
        )
        self.assertIsNotNone(result.session)

        session = result.session
        self.test_sessions.append(session)
        print(f"  ✓ Session created: {session.session_id}")

        return session

    @pytest.mark.sync
    def test_get_status_before_get_session(self):
        """Test using get_status before get_session for status-based decision making."""
        print("\n" + "=" * 60)
        print("TEST: Using get_status before get_session")
        print("=" * 60)

        # Create a test session
        session = self._create_test_session()

        # Step 1: Use get_status to check session status FIRST
        print(f"\nStep 1: Using get_status to check session status...")
        status_result = self.agent_bay.get_status(session.session_id)
        self.assertTrue(
            status_result.success, f"Failed to get session status: {status_result.error_message}"
        )
        
        # Get the actual session status using get_status method
        current_status = status_result.data.status if status_result.data else "UNKNOWN"
        print(f"  ✓ Current session status from get_status: {current_status}")
        
        # Step 2: Based on status, decide whether to call get_session
        print(f"\nStep 2: Making decision based on status...")
        if current_status == "RUNNING":
            print(f"  ✓ Status is {current_status}, proceeding with get_session call...")
            
            # Now use get_session for additional session info
            session_info = self.agent_bay.get_session(session.session_id)
            self.assertTrue(session_info.success, f"Failed to get session info: {session_info.error_message}")
            
            # Verify status consistency between get_status and get_session
            session_status_from_get_session = session_info.data.status if session_info.data else "UNKNOWN"
            print(f"  ✓ Session status from get_session: {session_status_from_get_session}")
            
            self.assertEqual(current_status, session_status_from_get_session, 
                            f"Status mismatch: get_status returned {current_status}, get_session returned {session_status_from_get_session}")
            print(f"  ✓ Status consistency verified between get_status and get_session")
        else:
            print(f"  ⚠ Status is {current_status}, skipping get_session call")
        
        # Step 3: Use status for list filtering
        print(f"\nStep 3: Using status for list filtering...")
        list_result = self.agent_bay.list(status=current_status)
        self.assertTrue(list_result.success, f"Failed to list sessions: {list_result.error_message}")
        
        # Verify session is in the list
        session_found = False
        for session_data in list_result.session_ids:
            if isinstance(session_data, dict):
                if session_data.get("sessionId") == session.session_id:
                    session_found = True
                    self.assertIn("sessionStatus", session_data, "sessionStatus field missing in list result")
                    self.assertIn("sessionId", session_data, "sessionId field missing in list result")
                    self.assertEqual(session_data["sessionStatus"], current_status)
                    break
            elif session_data == session.session_id:
                session_found = True
                break
        
        self.assertTrue(session_found, f"Session {session.session_id} not found in list with status {current_status}")
        print(f"  ✓ Session found in list with status {current_status}")

    @pytest.mark.sync
    def test_get_status_workflow_with_pause_resume(self):
        """Test complete workflow using get_status for pause/resume operations."""
        print("\n" + "=" * 60)
        print("TEST: get_status workflow with pause/resume")
        print("=" * 60)

        # Create a test session
        session = self._create_test_session()

        # Step 1: Check initial status with get_status
        print(f"\nStep 1: Checking initial status with get_status...")
        status_result = self.agent_bay.get_status(session.session_id)
        self.assertTrue(status_result.success, f"Failed to get session status: {status_result.error_message}")
        
        initial_status = status_result.data.status if status_result.data else "UNKNOWN"
        print(f"  ✓ Initial session status: {initial_status}")
        self.assertEqual(initial_status, "RUNNING")

        # Step 2: Pause the session
        print(f"\nStep 2: Pausing session...")
        pause_result = self.agent_bay.pause(session)
        self.assertTrue(pause_result.success, f"Pause failed: {pause_result.error_message}")
        print(f"  ✓ Session pause initiated successfully")

        # Wait a bit for pause to complete
        time.sleep(2)

        # Step 3: Check status after pause using get_status
        print(f"\nStep 3: Checking status after pause with get_status...")
        status_result = self.agent_bay.get_status(session.session_id)
        self.assertTrue(status_result.success, f"Failed to get session status: {status_result.error_message}")
        
        paused_status = status_result.data.status if status_result.data else "UNKNOWN"
        print(f"  ✓ Session status after pause: {paused_status}")
        self.assertIn(paused_status, ["PAUSED", "PAUSING"])

        # Step 4: Based on status, decide to resume
        if paused_status in ["PAUSED", "PAUSING"]:
            print(f"\nStep 4: Status is {paused_status}, proceeding with resume...")
            resume_result = self.agent_bay.resume(session)
            self.assertTrue(resume_result.success, f"Resume failed: {resume_result.error_message}")
            print(f"  ✓ Session resume initiated successfully")

            # Wait a bit for resume to complete
            time.sleep(2)

            # Step 5: Check final status with get_status
            print(f"\nStep 5: Checking final status with get_status...")
            status_result = self.agent_bay.get_status(session.session_id)
            self.assertTrue(status_result.success, f"Failed to get session status: {status_result.error_message}")
            
            final_status = status_result.data.status if status_result.data else "UNKNOWN"
            print(f"  ✓ Final session status: {final_status}")
            self.assertIn(final_status, ["RUNNING", "RESUMING"])

    @pytest.mark.sync
    def test_get_status_error_handling(self):
        """Test get_status error handling for non-existent session."""
        print("\n" + "=" * 60)
        print("TEST: get_status error handling")
        print("=" * 60)

        # Test with non-existent session ID
        non_existent_session_id = "non-existent-session-12345"
        print(f"\nTesting get_status with non-existent session: {non_existent_session_id}")

        status_result = self.agent_bay.get_status(non_existent_session_id)
        
        # Should return a failed result
        self.assertFalse(status_result.success)
        print(f"  ✓ get_status correctly returned failure for non-existent session")
        print(f"    Error: {status_result.error_message}")
        self.assertIn("not found", status_result.error_message.lower())

if __name__ == "__main__":
    unittest.main()
