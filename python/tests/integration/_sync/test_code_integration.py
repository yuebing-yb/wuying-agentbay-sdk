# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

import pytest
import os
from agentbay import AgentBay
from agentbay import CreateSessionParams


@pytest.fixture
def code_session():
    """Create a session for code execution tests."""
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")

    agent_bay = AgentBay(api_key=api_key)
    params = CreateSessionParams(image_id="code_latest")
    session_result = agent_bay.create(params)
    if not session_result.success or not session_result.session:
        pytest.skip(f"Failed to create session: {session_result.error_message}")
    
    session = session_result.session
    code_obj = session.code
    
    yield code_obj
    
    # Cleanup
    session.delete()


@pytest.fixture
def agent_bay_client():
    """Create an AgentBay client for complex tests that need multiple sessions."""
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    
    return AgentBay(api_key=api_key)


@pytest.mark.sync
def test_run_code_python_success(code_session):
    """Test successful Python code execution."""
    code = """
print("Hello, world!")
x = 1 + 1
print(x)
"""
    result = code_session.run_code(code, "python")

    print(f"Python code execution result: {result}")

    # Should have success, result, and request_id
    assert result.success
    assert result.result is not None
    assert result.request_id is not None
    assert "Hello, world!" in result.result
    assert "2" in result.result


@pytest.mark.sync
def test_run_alias_python_success(code_session):
    """Test code.run alias."""
    code = "print('Hello from alias')"
    result = code_session.run(code, "python")
    assert result.success
    assert "Hello from alias" in result.result


@pytest.mark.sync
def test_execute_alias_python_success(code_session):
    """Test code.execute alias."""
    code = "print('Hello from alias')"
    result = code_session.execute(code, "python")
    assert result.success
    assert "Hello from alias" in result.result

@pytest.mark.sync
def test_run_code_javascript_success(code_session):
    """Test successful JavaScript code execution."""
    code = """
console.log("Hello, world!");
const x = 1 + 1;
console.log(x);
"""
    result = code_session.run_code(code, "javascript")

    print(f"JavaScript code execution result: {result}")

    # Should have success, result, and request_id
    assert result.success
    assert result.result is not None
    assert result.request_id is not None
    assert "Hello, world!" in result.result
    assert "2" in result.result


@pytest.mark.sync
def test_run_code_language_case_insensitive_python(code_session):
    """Test case-insensitive language input for Python."""
    code = """
print("CASE_INSENSITIVE_OK")
""".strip()
    result = code_session.run_code(code, "PyThOn")
    assert result.success
    assert "CASE_INSENSITIVE_OK" in result.result


@pytest.mark.sync
def test_run_code_r_success(code_session):
    """Test successful R code execution."""
    code = """
cat("Hello, R!\\n")
x <- 1 + 1
cat(x, "\\n")
""".strip()
    result = code_session.run_code(code, "r")
    assert result.success
    assert "Hello, R!" in result.result
    assert "2" in result.result


@pytest.mark.sync
def test_run_code_java_success(code_session):
    """Test successful Java code execution."""
    code = """
System.out.println("Hello, Java!");
int x = 1 + 1;
System.out.println(x);
""".strip()
    result = code_session.run_code(code, "java")
    assert result.success
    assert "Hello, Java!" in result.result
    assert "2" in result.result


@pytest.mark.sync
def test_run_code_r_jupyter_context_persistence(code_session):
    """Test Jupyter-like context persistence for R (state persists across calls)."""
    setup_code = """
x <- 41
cat("CONTEXT_SETUP_DONE\\n")
""".strip()
    setup_result = code_session.run_code(setup_code, "R")
    assert setup_result.success
    assert "CONTEXT_SETUP_DONE" in setup_result.result

    use_code = """
cat(paste0("CONTEXT_VALUE:", x + 1, "\\n"))
""".strip()
    use_result = code_session.run_code(use_code, "r")
    assert use_result.success
    assert "CONTEXT_VALUE:42" in use_result.result


@pytest.mark.sync
def test_run_code_java_jupyter_context_persistence(code_session):
    """Test Jupyter-like context persistence for Java (state persists across calls)."""
    setup_code = """
int x = 41;
System.out.println("CONTEXT_SETUP_DONE");
""".strip()
    setup_result = code_session.run_code(setup_code, "JAVA")
    assert setup_result.success
    assert "CONTEXT_SETUP_DONE" in setup_result.result

    use_code = """
System.out.println("CONTEXT_VALUE:" + (x + 1));
""".strip()
    use_result = code_session.run_code(use_code, "java")
    assert use_result.success
    assert "CONTEXT_VALUE:42" in use_result.result

@pytest.mark.sync
def test_run_code_unsupported_language(code_session):
    """Test code execution with unsupported language."""
    code = "print('Hello, world!')"
    language = "ruby"
    
    result = code_session.run_code(code, language)

    # Should return failure for unsupported language
    assert not result.success
    assert result.error_message is not None

@pytest.mark.sync
def test_run_code_python_with_timeout(code_session):
    """Test Python code execution with custom timeout."""
    code = """
import time
print("Starting...")
time.sleep(2)
print("Completed after 2 seconds")
"""
    result = code_session.run_code(code, "python", timeout_s=10)

    print(f"Python code with timeout result: {result}")

    assert result.success
    assert result.result is not None
    assert "Starting..." in result.result
    assert "Completed after 2 seconds" in result.result

@pytest.mark.sync
def test_run_code_javascript_with_timeout(code_session):
    """Test JavaScript code execution with custom timeout."""
    code = """
console.log("Starting...");
setTimeout(() => {
    console.log("This should not appear");
}, 5000);
console.log("Immediate output");
"""
    result = code_session.run_code(code, "javascript", timeout_s=10)

    print(f"JavaScript code with timeout result: {result}")

    assert result.success
    assert result.result is not None
    assert "Starting..." in result.result
    assert "Immediate output" in result.result

@pytest.mark.sync
def test_run_code_python_file_operations(code_session):
    """Test Python code with file operations."""
    code = """
import os
# Create a test file
with open('/tmp/test_code_integration.txt', 'w') as f:
    f.write('Test content from Python code execution')

# Read it back
with open('/tmp/test_code_integration.txt', 'r') as f:
    content = f.read()
    print(f"File content: {content}")

# Clean up
os.remove('/tmp/test_code_integration.txt')
print("File operations completed successfully")
"""
    result = code_session.run_code(code, "python")

    print(f"Python file operations result: {result}")

    assert result.success
    assert result.result is not None
    assert "Test content from Python code execution" in result.result
    assert "File operations completed successfully" in result.result

@pytest.mark.sync
def test_run_code_python_error_handling(code_session):
    """Test Python code with error handling."""
    code = """
try:
    result = 10 / 0
except ZeroDivisionError as e:
    print(f"Caught error: {e}")
    print("Error handled successfully")
"""
    result = code_session.run_code(code, "python")

    print(f"Python error handling result: {result}")

    assert result.success
    assert result.result is not None
    assert "Caught error:" in result.result
    assert "Error handled successfully" in result.result

@pytest.mark.sync
def test_run_code_python_with_imports(code_session):
    """Test Python code with standard library imports."""
    code = """
import json
import datetime

data = {
    "message": "Hello from Python",
    "timestamp": str(datetime.datetime.now()),
    "numbers": [1, 2, 3, 4, 5]
}

json_str = json.dumps(data, indent=2)
print(json_str)

# Parse it back
parsed = json.loads(json_str)
print(f"Message: {parsed['message']}")
print(f"Numbers sum: {sum(parsed['numbers'])}")
"""
    result = code_session.run_code(code, "python")

    print(f"Python with imports result: {result}")

    assert result.success
    assert result.result is not None
    assert "Hello from Python" in result.result
    assert "Message: Hello from Python" in result.result
    assert "Numbers sum: 15" in result.result

@pytest.mark.sync
def test_run_code_cross_language_interop(code_session):
    """Test Python and JavaScript interoperability through file system."""
    import time

    # Step 1: Create a file with Python
    python_code = """
import json
data = {"language": "python", "value": 42}
with open('/tmp/interop_test.json', 'w') as f:
    json.dump(data, f)
print("Python wrote data to file")
"""
    result = code_session.run_code(python_code, "python")
    assert result.success
    assert "Python wrote data to file" in result.result

    time.sleep(1)

    # Step 2: Read and modify with JavaScript
    js_code = """
const fs = require('fs');
const data = JSON.parse(fs.readFileSync('/tmp/interop_test.json', 'utf8'));
console.log('JavaScript read data:', JSON.stringify(data));
data.language = 'javascript';
data.value = data.value * 2;
fs.writeFileSync('/tmp/interop_test.json', JSON.stringify(data));
console.log('JavaScript updated data in file');
"""
    result = code_session.run_code(js_code, "javascript")
    assert result.success
    assert "JavaScript read data" in result.result
    assert "JavaScript updated data in file" in result.result

    time.sleep(1)

    # Step 3: Verify with Python
    python_verify_code = """
import json
with open('/tmp/interop_test.json', 'r') as f:
    data = json.load(f)
print(f"Final data: {data}")
print(f"Language: {data['language']}")
print(f"Value: {data['value']}")
import os
os.remove('/tmp/interop_test.json')
print("Cleanup completed")
"""
    result = code_session.run_code(python_verify_code, "python")
    assert result.success
    assert "javascript" in result.result
    assert "84" in result.result
    assert "Cleanup completed" in result.result

@pytest.mark.sync
def test_3_2_complex_code_with_file_operations(agent_bay_client):
    """3.2 Complex Code with File Operations - should execute complex code with file operations"""
    # Step 1: Session creation
    session_params1 = CreateSessionParams(image_id="code_latest")
    session_params2 = CreateSessionParams(image_id="code_latest")

    session_result1 = agent_bay_client.create(session_params1)
    session_result2 = agent_bay_client.create(session_params2)

    assert session_result1.success
    assert session_result2.success

    session1 = session_result1.session
    session2 = session_result2.session

    code1 = session1.code
    code2 = session2.code
    
    try:

        # Step 7: Complex code test with file operations
        python_file_code = """
import os
import json

# Create a test file
with open('/tmp/python_test.txt', 'w') as f:
    f.write('Python file operation test')

# Read the file
with open('/tmp/python_test.txt', 'r') as f:
    content = f.read()

result = {"operation": "file_write_read", "content": content, "file_exists": os.path.exists('/tmp/python_test.txt')}
print(json.dumps(result))
""".strip()

        js_file_code = """
const fs = require('fs');

// Create a test file
fs.writeFileSync('/tmp/js_test.txt', 'JavaScript file operation test');

// Read the file
const content = fs.readFileSync('/tmp/js_test.txt', 'utf8');

const result = {
  operation: "file_write_read",
  content: content,
  file_exists: fs.existsSync('/tmp/js_test.txt')
};
console.log(JSON.stringify(result));
""".strip()

        python_file_result = code1.run_code(python_file_code, "python")
        js_file_result = code2.run_code(js_file_code, "javascript")

        assert python_file_result.success
        assert js_file_result.success

        assert "Python file operation test" in python_file_result.result
        assert "JavaScript file operation test" in js_file_result.result
    finally:
        # Cleanup sessions
        session1.delete()
        session2.delete()

@pytest.mark.sync
def test_3_2_code_execution_error_handling(agent_bay_client):
    """3.2 Code Execution Error Handling - should handle code execution errors gracefully"""
    # Step 1: Session creation
    session_params = CreateSessionParams(image_id="code_latest")

    session_result = agent_bay_client.create(session_params)
    assert session_result.success
    session = session_result.session

    code = session.code
    
    try:
        # Test Python code with syntax error
        bad_python_code = """
print("Hello"
# Missing closing parenthesis
""".strip()

        bad_result = code.run_code(bad_python_code, "python")
        assert bad_result.success
        assert bad_result.error_message is not None

        # Test code with runtime error
        runtime_error_code = """
undefined_variable = nonexistent_variable + 1
print(undefined_variable)
""".strip()

        runtime_result = code.run_code(runtime_error_code, "python")
        assert runtime_result.success
        assert "name 'nonexistent_variable' is not defined" in runtime_result.logs.stderr
    finally:
        # Cleanup session
        session.delete()
