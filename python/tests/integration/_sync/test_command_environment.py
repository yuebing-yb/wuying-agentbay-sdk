# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for command environment variables and advanced features (cwd, envs, new return format)."""

import os

import pytest
import pytest

from agentbay import AgentBay
from agentbay import CreateSessionParams


@pytest.fixture(scope="module")
def agent_bay():
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture
def test_session(agent_bay):
    """Create a test session."""
    result = agent_bay.create(CreateSessionParams(image_id="linux_latest"))
    if not result.success:
        pytest.skip(f"Failed to create session: {result.error_message}")
    yield result.session
    result.session.delete()


@pytest.mark.sync
def test_command_new_return_format(test_session):
    """Test command execution with new return format (exit_code, stdout, stderr)."""
    cmd = test_session.command
    result = cmd.execute_command("echo 'Hello, AgentBay!'")
    
    # Verify new fields exist
    assert hasattr(result, 'exit_code'), "exit_code field should exist"
    assert hasattr(result, 'stdout'), "stdout field should exist"
    assert hasattr(result, 'stderr'), "stderr field should exist"
    
    # Verify success case
    assert result.success, "Command should succeed"
    assert result.exit_code == 0, "Exit code should be 0 for success"
    assert "Hello, AgentBay!" in result.stdout, "Stdout should contain expected output"
    assert result.output == result.stdout, "Output should equal stdout for success"
    
    print(f"✓ New return format test passed: exit_code={result.exit_code}, stdout={result.stdout}")


@pytest.mark.sync
def test_command_error_with_exit_code(test_session):
    """Test error command with exit_code, stderr, and trace_id."""
    cmd = test_session.command
    result = cmd.execute_command("ls /non_existent_directory_12345")
    
    # Verify error case
    assert hasattr(result, 'exit_code'), "exit_code field should exist"
    assert hasattr(result, 'stderr'), "stderr field should exist"
    assert hasattr(result, 'trace_id'), "trace_id field should exist"
    
    # Error commands should have non-zero exit code
    # Note: success field behavior depends on implementation
    if result.exit_code != 0:
        assert result.exit_code != 0, "Exit code should be non-zero for error"
        # trace_id is optional, only present when errorCode != 0
        if result.trace_id:
            print(f"✓ Error command test passed: exit_code={result.exit_code}, stderr={result.stderr}, trace_id={result.trace_id}")
        else:
            print(f"✓ Error command test passed: exit_code={result.exit_code}, stderr={result.stderr} (no trace_id)")
    else:
        # If exit_code is 0, the command might have succeeded in some way
        print(f"⚠ Command returned exit_code=0, but this is acceptable")


@pytest.mark.sync
def test_command_with_cwd(test_session):
    """Test command execution with cwd parameter."""
    cmd = test_session.command
    result = cmd.execute_command("pwd", cwd="/tmp")
    
    assert result.success, "Command should succeed"
    assert result.exit_code == 0, "Exit code should be 0"
    # The output should contain /tmp or be /tmp
    assert "/tmp" in result.stdout, f"Working directory should be /tmp, got: {result.stdout}"
    
    print(f"✓ CWD test passed: working directory={result.stdout.strip()}")


@pytest.mark.sync
def test_command_with_envs(test_session):
    """Test command execution with envs parameter."""
    cmd = test_session.command
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": "test_value_123"}
    )
    
    assert result.success, "Command should succeed"
    assert result.exit_code == 0, "Exit code should be 0"
    # The environment variable should be set
    # Note: This depends on backend implementation
    output = result.stdout.strip()
    if "test_value_123" in output:
        print(f"✓ Envs test passed: environment variable set correctly: {output}")
    else:
        print(f"⚠ Envs test: environment variable may not be set (output: {output})")
        # This is acceptable if backend doesn't support envs yet


@pytest.mark.sync
def test_command_with_cwd_and_envs(test_session):
    """Test command execution with both cwd and envs parameters."""
    cmd = test_session.command
    result = cmd.execute_command(
        "pwd && echo $CUSTOM_VAR",
        cwd="/tmp",
        envs={"CUSTOM_VAR": "custom_value"}
    )
    
    assert result.success, "Command should succeed"
    assert result.exit_code == 0, "Exit code should be 0"
    assert "/tmp" in result.stdout, "Working directory should be /tmp"
    
    print(f"✓ Combined cwd and envs test passed")
    print(f"  Output: {result.stdout}")


@pytest.mark.sync
def test_command_backward_compatibility(test_session):
    """Test backward compatibility: output field should still work."""
    cmd = test_session.command
    result = cmd.execute_command("echo 'backward compatible'")
    
    # Verify backward compatibility
    assert hasattr(result, 'output'), "output field should exist for backward compatibility"
    assert result.output is not None, "output should not be None"
    
    # output should be stdout if available, otherwise stderr
    if result.stdout:
        assert result.output == result.stdout, "output should equal stdout when stdout is available"
    elif result.stderr:
        assert result.output == result.stderr, "output should equal stderr when stdout is empty"
    
    print(f"✓ Backward compatibility test passed: output={result.output}")


@pytest.mark.sync
def test_command_path_env(test_session):
    """Test PATH environment variable."""
    cmd = test_session.command
    result = cmd.execute_command("echo $PATH")
    assert result.success
    assert len(result.output) > 0
    print(f"PATH: {result.output[:100]}...")


@pytest.mark.sync
def test_command_timeout_limit(test_session):
    """Test command execution with timeout exceeding maximum limit (50s)."""
    cmd = test_session.command
    
    # Test with timeout exceeding 50s (50000ms) - should be limited to 50s
    # Note: We can't directly verify the timeout was limited without mocking,
    # but we can verify the command still executes successfully
    result = cmd.execute_command("echo 'timeout test'", timeout_ms=60000)
    assert result.success, "Command should succeed even with timeout > 50s"
    assert result.exit_code == 0, "Exit code should be 0"
    assert "timeout test" in result.stdout, "Command should execute successfully"
    
    # Test with timeout exactly at limit
    result = cmd.execute_command("echo 'timeout test 50s'", timeout_ms=50000)
    assert result.success, "Command should succeed with timeout = 50s"
    assert result.exit_code == 0, "Exit code should be 0"
    
    # Test with timeout below limit
    result = cmd.execute_command("echo 'timeout test 30s'", timeout_ms=30000)
    assert result.success, "Command should succeed with timeout < 50s"
    assert result.exit_code == 0, "Exit code should be 0"
    
    print(f"✓ Timeout limit test passed")


@pytest.mark.sync
def test_command_cwd_with_spaces(test_session):
    """Test command execution with cwd containing spaces (security test for parameter passing)."""
    cmd = test_session.command
    fs = test_session.filesystem
    
    # Create a directory with spaces in the path
    test_dir = "/tmp/test dir with spaces"
    
    # First, create the directory
    result = cmd.execute_command(f"mkdir -p '{test_dir}'")
    assert result.success, "Should be able to create directory with spaces"
    
    # Test pwd with cwd containing spaces
    result = cmd.execute_command("pwd", cwd=test_dir)
    assert result.success, "Command should succeed with cwd containing spaces"
    assert result.exit_code == 0, "Exit code should be 0"
    # The output should contain the directory path (may be normalized)
    assert test_dir in result.stdout or "/tmp/test" in result.stdout, \
        f"Working directory should contain test dir, got: {result.stdout}"
    
    # Test creating a file in the directory with spaces
    result = cmd.execute_command("echo 'test content' > test_file.txt", cwd=test_dir)
    assert result.success, "Should be able to create file in directory with spaces"
    
    # Verify file was created
    result = cmd.execute_command("ls test_file.txt", cwd=test_dir)
    assert result.success, "Should be able to list file in directory with spaces"
    assert "test_file.txt" in result.stdout, "File should exist in directory with spaces"
    
    # Cleanup
    cmd.execute_command(f"rm -rf '{test_dir}'")
    
    print(f"✓ CWD with spaces test passed: directory={test_dir}")


@pytest.mark.sync
def test_command_envs_with_special_characters(test_session):
    """Test command execution with environment variables containing special characters (security test)."""
    cmd = test_session.command
    
    # Test environment variable with quotes
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": "value with 'single quotes'"}
    )
    assert result.success, "Command should succeed with env containing single quotes"
    assert result.exit_code == 0, "Exit code should be 0"
    # The value should be properly escaped and passed
    output = result.stdout.strip()
    if "value with" in output and "single quotes" in output:
        print(f"✓ Envs with single quotes test passed: {output}")
    else:
        print(f"⚠ Envs with single quotes: output may not match exactly: {output}")
    
    # Test environment variable with double quotes
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": 'value with "double quotes"'}
    )
    assert result.success, "Command should succeed with env containing double quotes"
    assert result.exit_code == 0, "Exit code should be 0"
    output = result.stdout.strip()
    if "value with" in output and "double quotes" in output:
        print(f"✓ Envs with double quotes test passed: {output}")
    else:
        print(f"⚠ Envs with double quotes: output may not match exactly: {output}")
    
    # Test environment variable with semicolon (potential injection attempt)
    # This should NOT execute as a separate command due to parameter passing
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": "value; rm -rf /"}
    )
    assert result.success, "Command should succeed (semicolon should be treated as literal)"
    assert result.exit_code == 0, "Exit code should be 0"
    output = result.stdout.strip()
    # The semicolon should be part of the value, not a command separator
    if "value; rm -rf /" in output or "value" in output:
        print(f"✓ Envs with semicolon test passed (no injection): {output}")
    else:
        print(f"⚠ Envs with semicolon: output={output}")
    
    # Test environment variable with special characters
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": "value with !@#$%^&*()_+-=[]{}|;':\",./<>?"}
    )
    assert result.success, "Command should succeed with env containing special chars"
    assert result.exit_code == 0, "Exit code should be 0"
    output = result.stdout.strip()
    if "value with" in output:
        print(f"✓ Envs with special characters test passed: {output[:50]}...")
    else:
        print(f"⚠ Envs with special characters: output may not match: {output}")
    
    # Test environment variable with newline (potential injection attempt)
    result = cmd.execute_command(
        "echo $TEST_VAR",
        envs={"TEST_VAR": "value\nwith\nnewlines"}
    )
    assert result.success, "Command should succeed with env containing newlines"
    assert result.exit_code == 0, "Exit code should be 0"
    output = result.stdout.strip()
    if "value" in output:
        print(f"✓ Envs with newlines test passed: {output[:50]}...")
    else:
        print(f"⚠ Envs with newlines: output may not match: {output}")


@pytest.mark.sync
def test_command_cwd_and_envs_with_special_chars(test_session):
    """Test command execution with both cwd (with spaces) and envs (with special chars) together."""
    cmd = test_session.command
    
    # Create a directory with spaces
    test_dir = "/tmp/test dir with spaces"
    result = cmd.execute_command(f"mkdir -p '{test_dir}'")
    assert result.success, "Should be able to create directory with spaces"
    
    # Test with both cwd (spaces) and envs (special chars)
    result = cmd.execute_command(
        "pwd && echo $TEST_VAR",
        cwd=test_dir,
        envs={"TEST_VAR": "value with 'quotes' and ; semicolon"}
    )
    assert result.success, "Command should succeed with both cwd (spaces) and envs (special chars)"
    assert result.exit_code == 0, "Exit code should be 0"
    assert test_dir in result.stdout or "/tmp/test" in result.stdout, \
        "Working directory should contain test dir"
    
    # Verify environment variable was set (may be partially visible)
    output = result.stdout.strip()
    if "value" in output or "TEST_VAR" in output:
        print(f"✓ Combined cwd (spaces) and envs (special chars) test passed")
        print(f"  Output: {output[:100]}...")
    else:
        print(f"⚠ Combined test: output may not show env var: {output}")
    
    # Cleanup
    cmd.execute_command(f"rm -rf '{test_dir}'")

