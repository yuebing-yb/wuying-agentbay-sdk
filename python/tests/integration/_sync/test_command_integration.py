# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for Command functionality."""
import os
import time

import pytest

from agentbay import AgentBay
from agentbay._common.params.session_params import CreateSessionParams


@pytest.fixture(scope="module")
def agent_bay():
    """Create an AsyncAgentBay instance."""
    api_key = os.getenv("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture(scope="module")
def command_session(agent_bay):
    """Create a session for command testing."""
    time.sleep(3)  # Ensure a delay to avoid session creation conflicts
    params = CreateSessionParams(
        image_id="code_latest",
    )
    session_result = agent_bay.create(params)
    if not session_result.success or not session_result.session:
        pytest.skip("Failed to create session")

    session = session_result.session  # Assuming session has direct access to command
    yield session

    # Clean up session
    try:
        agent_bay.delete(session)
    except Exception as e:
        print(f"Warning: Error deleting session: {e}")


def test_execute_command_success(command_session):
    """Test executing a shell command successfully."""
    command = command_session.command  # Assuming direct access to command interface
    result = command.execute_command("echo 'Hello, AgentBay!'")
    print(f"Command execution result: {result.output}")
    assert result.success
    assert result.output.strip() == "Hello, AgentBay!"
    assert result.request_id != ""
    assert result.error_message == ""


def test_execute_command_with_timeout(command_session):
    """Test executing a shell command with a timeout."""
    command = command_session.command  # Assuming direct access to command interface
    command_str = "sleep 5"
    timeout_ms = 1000  # 1 second timeout
    result = command.execute_command(command_str, timeout_ms)
    print(f"Command execution result with timeout: {result}")
    assert not result.success
    assert result.request_id != ""
    assert result.error_message != ""
    assert result.output == ""


def test_command_error_handling(command_session):
    """3.1 Command Error Handling - should handle command errors and edge cases"""
    command = command_session.command  # Assuming direct access to command interface

    # Test invalid command
    invalid_result = command.execute_command("invalid_command_12345")
    assert not invalid_result.success
    assert invalid_result.error_message is not None

    # Test command with permission issues (trying to write to protected directory)
    permission_result = command.execute_command('echo "test" > /root/protected.txt')
    # This might succeed or fail depending on the environment, but should not crash
    assert isinstance(permission_result.success, bool)

    # Test long-running command with timeout considerations
    time_command = 'echo "completed"'
    time_result = command.execute_command(time_command)
    print(f"Command output: {time_result}")
    assert time_result.success
    assert "completed" in time_result.output
