import time
# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for Computer application management functionality."""

import os

import pytest
import pytest

from agentbay import AgentBay
from agentbay import CreateSessionParams


@pytest.fixture(scope="module")
def agent_bay():
    """Create AgentBay instance."""
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture
def session(agent_bay):
    """Create a session with windows_latest image."""
    print("\nCreating session for computer apps testing...")
    session_param = CreateSessionParams(image_id="windows_latest")
    result = agent_bay.create(session_param)
    assert result.success, f"Failed to create session: {result.error_message}"
    session = result.session
    print(f"Session created with ID: {session.session_id}")
    yield session
    print("\nCleaning up: Deleting the session...")
    session.delete()


@pytest.mark.sync
def test_get_installed_apps(session):
    """Test getting list of installed applications."""
    # Arrange
    print("\nTest: Getting installed apps...")

    # Act
    result = session.computer.get_installed_apps()

    # Assert
    assert result.success, f"Get installed apps failed: {result.error_message}"
    assert result.data is not None, "Apps list should not be None"
    assert isinstance(result.data, list), "Apps should be a list"
    print(f"Found {len(result.data)} installed apps")

    if len(result.data) > 0:
        app = result.data[0]
        assert hasattr(app, "name"), "App should have name"
        assert hasattr(app, "start_cmd"), "App should have start_cmd"
        print(f"First app: {app.name}")


@pytest.mark.sync
def test_start_app(session):
    """Test starting an application."""
    # Arrange
    print("\nTest: Starting notepad app...")

    # Act - Try to start notepad (should be available on Windows)
    result = session.computer.start_app("notepad.exe")

    # Assert
    assert result.success, f"Start app failed: {result.error_message}"
    assert result.data is not None, "Process list should not be None"
    assert isinstance(result.data, list), "Processes should be a list"
    print(f"Started {len(result.data)} process(es)")

    if len(result.data) > 0:
        process = result.data[0]
        assert hasattr(process, "pname"), "Process should have pname"
        assert hasattr(process, "pid"), "Process should have pid"
        print(f"Process: {process.pname}, PID: {process.pid}")


@pytest.mark.sync
def test_start_app_with_params(session):
    """Test starting an application with parameters."""
    # Arrange
    print("\nTest: Starting cmd.exe with work directory...")

    # Act - Try to start cmd.exe
    # Note: 'activity' is for mobile, so we test work_directory here
    result = session.computer.start_app("cmd.exe", work_directory="C:\\")

    # Assert
    assert result.success, f"Start app with params failed: {result.error_message}"
    assert len(result.data) > 0, "Should have started at least one process"

    # Cleanup
    session.computer.stop_app_by_pname("cmd.exe")


@pytest.mark.sync
def test_stop_app(session):
    """Test stopping an application."""
    # Arrange
    print("\nTest: Stopping notepad app...")

    # Start notepad first
    start_result = session.computer.start_app("notepad.exe")
    assert start_result.success, "Failed to start notepad for test"

    # Act - Stop notepad
    result = session.computer.stop_app_by_pname("notepad.exe")

    # Assert
    assert result.success, f"Stop app failed: {result.error_message}"
    print("App stopped successfully")


@pytest.mark.sync
def test_app_lifecycle(session):
    """Test full application lifecycle: Find -> Start -> Verify -> Stop -> Verify."""
    print("\nTest: App Lifecycle (Find -> Start -> Verify -> Stop -> Verify)...")

    # 1. Get Installed Apps
    installed_apps = session.computer.get_installed_apps()

    start_cmd = "notepad.exe"
    if installed_apps.success and installed_apps.data:
        for app in installed_apps.data:
            if "Notepad" in app.name or app.start_cmd == "notepad.exe":
                start_cmd = app.start_cmd
                print(f"Found app in installed list: {app.name} ({app.start_cmd})")
                break

    # 2. Start App
    print(f"Starting app with command: {start_cmd}")
    start_result = session.computer.start_app(start_cmd)
    assert start_result.success, f"Failed to start app: {start_result.error_message}"
    assert len(start_result.data) > 0, "No processes returned"

    pid = start_result.data[0].pid
    print(f"Started app with PID: {pid}")

    # Wait for window
    print("Verifying app visibility (polling)...")
    found_in_visible = False
    
    # Poll for up to 10 seconds
    for i in range(5):
        visible_apps = session.computer.list_visible_apps()
        if visible_apps.success and visible_apps.data:
            for p in visible_apps.data:
                if p.pid == pid:
                    found_in_visible = True
                    break
        
        if found_in_visible:
            print("App found in visible list")
            break
            
        print(f"App PID {pid} not visible yet, waiting... (attempt {i+1})")
        time.sleep(2)

    assert found_in_visible, f"Started app (PID {pid}) should be in visible apps list after starting"
    print("Confirmed app is visible")

    # 4. Stop App by PID
    stop_result = session.computer.stop_app_by_pid(pid)
    assert stop_result.success, f"Failed to stop app: {stop_result.error_message}"
    print(f"Stopped app with PID: {pid}")

    # 5. Verify it's gone
    time.sleep(2)
    visible_apps_after = session.computer.list_visible_apps()

    found_after_stop = False
    if visible_apps_after.data:
        for p in visible_apps_after.data:
            if p.pid == pid:
                found_after_stop = True
                break

    assert not found_after_stop, f"App (PID {pid}) should not be in visible apps list after stopping"
    print("Confirmed app is no longer visible")
