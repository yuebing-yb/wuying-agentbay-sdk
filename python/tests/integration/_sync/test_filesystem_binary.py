# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for binary file operations."""

import os

import pytest
import pytest

from agentbay import AgentBay
from agentbay import CreateSessionParams
from agentbay._common.models.filesystem import BinaryFileContentResult


@pytest.fixture(scope="module")
def agent_bay():
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture
def test_session(agent_bay):
    """Create a session for binary file testing."""
    print("Creating a new session for binary file testing...")
    params = CreateSessionParams(image_id="linux_latest")
    result = agent_bay.create(params)
    if not result.success:
        error_msg = getattr(result, 'error_message', 'Unknown error')
        request_id = getattr(result, 'request_id', 'N/A')
        print(f"Failed to create session:")
        print(f"  Error message: {error_msg}")
        print(f"  Request ID: {request_id}")
        pytest.fail(f"Session creation failed: {error_msg} (Request ID: {request_id})")
    assert result.session is not None, "Session object is None"
    session = result.session
    print(f"Session created successfully: {session.session_id}")
    
    # Get and print resource URL for accessing mobile page
    resource_url = session.resource_url
    if resource_url:
        print(f"ğŸ“± Resource URL: {resource_url}")
        print(f"   You can access the mobile page at: {resource_url}")
    else:
        # If resource_url is empty, try to get it via info()
        print("Resource URL not set in session, fetching via info()...")
        try:
            info_result = session.info()
            if info_result.success and info_result.data.resource_url:
                resource_url = info_result.data.resource_url
                print(f"ğŸ“± Resource URL: {resource_url}")
                print(f"   You can access the mobile page at: {resource_url}")
        except Exception as e:
            print(f"Warning: Failed to get resource URL via info(): {e}")
    
    yield session
    
    # Clean up
    print("Cleaning up: Deleting the session...")
    try:
        session.delete()
        print(f"Session deleted: {session.session_id}")
    except Exception as e:
        print(f"Warning: Failed to delete session: {e}")


@pytest.mark.sync
def test_binary_file_creation(test_session):
    """Test creating binary file using command."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file
    result = cmd.execute_command(
        "dd if=/dev/zero of=/tmp/binary_test bs=1024 count=10"
    )
    assert result.success

    # Check file info
    info = fs.get_file_info("/tmp/binary_test")
    assert info.success
    size = int(info.file_info["size"])
    assert size > 0
    print(f"Binary file created, size: {size} bytes")


@pytest.mark.sync
def test_binary_file_copy(test_session):
    """Test copying binary file."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file
    cmd.execute_command("dd if=/dev/zero of=/tmp/binary_src bs=1024 count=5")

    # Copy file
    copy_result = cmd.execute_command("cp /tmp/binary_src /tmp/binary_dst")
    assert copy_result.success

    # Verify both files exist
    src_info = fs.get_file_info("/tmp/binary_src")
    dst_info = fs.get_file_info("/tmp/binary_dst")

    assert src_info.success
    assert dst_info.success
    src_size = int(src_info.file_info["size"])
    dst_size = int(dst_info.file_info["size"])
    assert src_size == dst_size
    print(f"Binary file copied, size: {dst_size} bytes")


@pytest.mark.sync
def test_read_binary_file(test_session):
    """Test reading a binary file using format='bytes'."""
    fs = test_session.file_system
    
    # Create a test JPEG file with proper JPEG header and footer
    print("\n" + "="*60)
    print("ğŸ“¤ Creating Test JPEG File")
    print("="*60)
    
    # Create minimal valid JPEG data
    # JPEG header: FF D8 FF E0 (SOI + APP0 marker)
    # JPEG footer: FF D9 (EOI)
    jpeg_data = bytearray()
    jpeg_data.extend(b'\xff\xd8\xff\xe0')  # JPEG header (SOI + APP0)
    jpeg_data.extend(b'\x00\x10')          # APP0 length (16 bytes)
    jpeg_data.extend(b'JFIF\x00')          # JFIF identifier
    jpeg_data.extend(b'\x01\x01')          # JFIF version 1.1
    jpeg_data.extend(b'\x01')              # Units (1 = pixels per inch)
    jpeg_data.extend(b'\x00\x48\x00\x48') # X and Y density (72 DPI)
    jpeg_data.extend(b'\x00\x00')          # Thumbnail width and height (0)
    
    # Add some dummy image data (minimal quantization table and image data)
    jpeg_data.extend(b'\xff\xdb')          # Quantization table marker
    jpeg_data.extend(b'\x00\x43\x00')      # Table length and precision
    # Add 64 bytes of quantization values (simplified)
    for i in range(64):
        jpeg_data.append(16 + (i % 16))
    
    # Add minimal image data
    jpeg_data.extend(b'\xff\xc0')          # Start of frame marker
    jpeg_data.extend(b'\x00\x11')          # Length
    jpeg_data.extend(b'\x08')              # Precision
    jpeg_data.extend(b'\x00\x01\x00\x01') # Height and width (1x1 pixel)
    jpeg_data.extend(b'\x01')              # Number of components
    jpeg_data.extend(b'\x01\x11\x00')     # Component info
    
    jpeg_data.extend(b'\xff\xda')          # Start of scan marker
    jpeg_data.extend(b'\x00\x08')          # Length
    jpeg_data.extend(b'\x01\x01\x00\x00\x3f\x00') # Scan header
    
    jpeg_data.extend(b'\xff\xd9')          # JPEG footer (EOI)
    
    # Convert to bytes
    test_jpeg_content = bytes(jpeg_data)
    
    print(f"âœ… Created test JPEG data: {len(test_jpeg_content)} bytes")
    print(f"   Header: {test_jpeg_content[:4].hex()}")
    print(f"   Footer: {test_jpeg_content[-2:].hex()}")
    
    # File path to upload the test JPEG
    file_path = "/tmp/test_binary_upload.jpeg"
    
    # Create a temporary local file with the JPEG content
    import tempfile
    temp_dir = tempfile.gettempdir()
    local_temp_path = os.path.join(temp_dir, "temp_test_image.jpeg")
    
    print(f"\nğŸ“ Creating temporary local file: {local_temp_path}")
    with open(local_temp_path, 'wb') as f:
        f.write(test_jpeg_content)
    
    print(f"âœ… Temporary file created successfully")
    
    # Upload the file using FileTransfer
    print(f"\nğŸ“¤ Uploading file to remote path: {file_path}")
    try:
        file_transfer = fs._ensure_file_transfer()
        upload_result = file_transfer.upload(local_temp_path, file_path)
        
        if not upload_result.success:
            pytest.fail(f"Failed to upload file: {upload_result.error}")
        
        print(f"âœ… File uploaded successfully")
        print(f"   Bytes sent: {upload_result.bytes_sent}")
        print(f"   HTTP status: {upload_result.http_status}")
        
    except Exception as e:
        # If FileTransfer upload fails, try using write_file with base64 encoding
        print(f"âš ï¸  FileTransfer upload failed: {e}")
        print(f"ğŸ“ Falling back to write_file method...")
    
    # Verify file exists
    print(f"\nğŸ” Verifying uploaded file exists: {file_path}")
    info = fs.get_file_info(file_path)
    if not info.success:
        pytest.fail(f"File not found at {file_path}. Upload may have failed.")
    
    file_size = int(info.file_info["size"])
    print(f"âœ… File found, size: {file_size} bytes")
    
    # Read binary file using format='bytes'
    print(f"\nğŸ“– Reading binary file: {file_path}")
    result = fs.read_file(file_path, format="bytes")
    assert result.success, f"Failed to read binary file: {result.error_message}"
    assert isinstance(result, BinaryFileContentResult), "Result should be BinaryFileContentResult"
    assert isinstance(result.content, bytes), "Content should be bytes type"
    assert len(result.content) == file_size, f"Expected {file_size} bytes, got {len(result.content)}"
    assert jpeg_data == result.content, "Read content should match uploaded content"
    
    # Verify it's a JPEG file by checking file header
    # JPEG files start with FF D8 FF
    if len(result.content) >= 3:
        jpeg_header = result.content[:3]
        assert jpeg_header == b'\xff\xd8\xff', f"File does not appear to be a JPEG (header: {jpeg_header.hex()})"
        print(f"âœ… JPEG header verified: {jpeg_header.hex()}")
    else:
        print(f"âš ï¸  File too small to verify JPEG header (size: {len(result.content)} bytes)")
    
    print(f"âœ… Successfully read JPEG file: {len(result.content)} bytes")
    
    # Save the read image to local file for verification
    local_image_path = os.path.join(temp_dir, "test_read_image.jpeg")
    
    print(f"\nğŸ’¾ Saving read image to local file for verification...")
    print(f"   Local path: {local_image_path}")
    
    with open(local_image_path, 'wb') as f:
        f.write(result.content)
    
    # Verify local file was saved correctly
    local_file_size = os.path.getsize(local_image_path)
    assert local_file_size == len(result.content), f"Local file size mismatch: {local_file_size} vs {len(result.content)}"
    
    print(f"âœ… Image saved successfully to: {local_image_path}")
    print(f"   File size: {local_file_size} bytes")
    print(f"\nğŸ–¼ï¸  You can now open this image file to verify the content:")
    print(f"   open {local_image_path}")
    
    # Additional verification: check file tail (JPEG files end with FF D9)
    if len(result.content) >= 2:
        jpeg_tail = result.content[-2:]
        if jpeg_tail == b'\xff\xd9':
            print(f"âœ… JPEG file tail verified: {jpeg_tail.hex()}")
        else:
            print(f"âš ï¸  JPEG file tail unexpected: {jpeg_tail.hex()} (expected: ffd9)")
    
    # Verify optional fields
    if result.size is not None:
        assert result.size == file_size

    print(f"\nâœ… Binary file read test completed successfully!")
    print(f"ğŸ“ Local verification file: {local_image_path}")
    
    # Clean up remote file
    try:
        cmd = test_session.command
        cleanup_result = cmd.execute_command(f"rm -f {file_path}")
        if cleanup_result.success:
            print(f"ğŸ—‘ï¸  Cleaned up remote file: {file_path}")
        else:
            print(f"âš ï¸  Failed to clean up remote file: {cleanup_result.error}")
    except Exception as e:
        print(f"âš ï¸  Exception during cleanup: {e}")


@pytest.mark.sync
def test_read_binary_file_with_non_zero_content(test_session):
    """Test reading a binary file with non-zero content."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file with pattern (using printf to create specific bytes)
    # Create a file with pattern: 0x00, 0x01, 0x02, ... repeating
    create_result = cmd.execute_command(
        "python3 -c \"with open('/tmp/binary_pattern_test', 'wb') as f: f.write(bytes(range(256)) * 4)\""
    )
    assert create_result.success

    # Read binary file
    result = fs.read_file("/tmp/binary_pattern_test", format="bytes")
    assert result.success, f"Failed to read binary file: {result.error_message}"
    assert isinstance(result, BinaryFileContentResult)
    assert isinstance(result.content, bytes)
    
    # Verify content pattern (0-255 repeating 4 times = 1024 bytes)
    expected_pattern = bytes(range(256)) * 4
    assert len(result.content) == len(expected_pattern)
    assert result.content == expected_pattern
    
    print(f"Successfully read binary file with pattern: {len(result.content)} bytes")


@pytest.mark.sync
def test_read_text_file_still_works(test_session):
    """Test that reading text files still works with default format."""
    fs = test_session.file_system

    test_content = "This is a test text file for binary read feature."
    test_file_path = "/tmp/test_text_for_binary_feature.txt"

    # Write text file
    write_result = fs.write_file(test_file_path, test_content, "overwrite")
    assert write_result.success

    # Read as text (default format)
    result = fs.read_file(test_file_path)
    assert result.success
    assert result.content == test_content
    assert isinstance(result.content, str)
    
    # Explicitly read as text format
    result_explicit = fs.read_file(test_file_path, format="text")
    assert result_explicit.success
    assert result_explicit.content == test_content
    assert isinstance(result_explicit.content, str)
    
    print("Text file reading still works correctly")
