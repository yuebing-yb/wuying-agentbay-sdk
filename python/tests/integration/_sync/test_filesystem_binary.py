import time
# DO NOT EDIT THIS FILE MANUALLY.
# This file is auto-generated by scripts/generate_sync.py

"""Integration tests for binary file operations."""

import os

import pytest
import pytest

from agentbay import AgentBay
from agentbay import CreateSessionParams
from agentbay._common.models.filesystem import BinaryFileContentResult


@pytest.fixture(scope="module")
def agent_bay():
    api_key = os.environ.get("AGENTBAY_API_KEY")
    if not api_key:
        pytest.skip("AGENTBAY_API_KEY environment variable not set")
    return AgentBay(api_key=api_key)


@pytest.fixture
def test_session(agent_bay):
    """Create a session for binary file testing."""
    print("Creating a new session for binary file testing...")
    params = CreateSessionParams(image_id="imgc-0aae4rgien5oudgb6")
    result = agent_bay.create(params)
    if not result.success:
        error_msg = getattr(result, 'error_message', 'Unknown error')
        request_id = getattr(result, 'request_id', 'N/A')
        print(f"Failed to create session:")
        print(f"  Error message: {error_msg}")
        print(f"  Request ID: {request_id}")
        pytest.fail(f"Session creation failed: {error_msg} (Request ID: {request_id})")
    assert result.session is not None, "Session object is None"
    session = result.session
    print(f"Session created successfully: {session.session_id}")
    
    # Get and print resource URL for accessing mobile page
    resource_url = session.resource_url
    if resource_url:
        print(f"ğŸ“± Resource URL: {resource_url}")
        print(f"   You can access the mobile page at: {resource_url}")
    else:
        # If resource_url is empty, try to get it via info()
        print("Resource URL not set in session, fetching via info()...")
        try:
            info_result = session.info()
            if info_result.success and info_result.data.resource_url:
                resource_url = info_result.data.resource_url
                print(f"ğŸ“± Resource URL: {resource_url}")
                print(f"   You can access the mobile page at: {resource_url}")
        except Exception as e:
            print(f"Warning: Failed to get resource URL via info(): {e}")
    
    yield session
    
    # Clean up
    print("Cleaning up: Deleting the session...")
    try:
        session.delete()
        print(f"Session deleted: {session.session_id}")
    except Exception as e:
        print(f"Warning: Failed to delete session: {e}")


@pytest.mark.sync
def test_binary_file_creation(test_session):
    """Test creating binary file using command."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file
    result = cmd.execute_command(
        "dd if=/dev/zero of=/tmp/binary_test bs=1024 count=10"
    )
    assert result.success

    # Check file info
    info = fs.get_file_info("/tmp/binary_test")
    assert info.success
    size = int(info.file_info["size"])
    assert size > 0
    print(f"Binary file created, size: {size} bytes")


@pytest.mark.sync
def test_binary_file_copy(test_session):
    """Test copying binary file."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file
    cmd.execute_command("dd if=/dev/zero of=/tmp/binary_src bs=1024 count=5")

    # Copy file
    copy_result = cmd.execute_command("cp /tmp/binary_src /tmp/binary_dst")
    assert copy_result.success

    # Verify both files exist
    src_info = fs.get_file_info("/tmp/binary_src")
    dst_info = fs.get_file_info("/tmp/binary_dst")

    assert src_info.success
    assert dst_info.success
    src_size = int(src_info.file_info["size"])
    dst_size = int(dst_info.file_info["size"])
    assert src_size == dst_size
    print(f"Binary file copied, size: {dst_size} bytes")


@pytest.mark.sync
def test_read_binary_file(test_session):
    """Test reading a binary file using format='bytes'."""
    fs = test_session.file_system
    
    # File path where user will manually upload the JPEG file
    file_path = "/sdcard/Download/test.jpeg"
    
    print("\n" + "="*60)
    print("ğŸ“¤ Manual Upload Required")
    print("="*60)
    print(f"Please upload a JPEG file to: {file_path}")
    print("You can access the mobile page using the Resource URL shown above.")
    print("="*60 + "\n")
    
    # Wait for user to upload the file
    import asyncio
    print("â³ Waiting 30 seconds for file upload...")
    print("   (You can upload the file now)")
    time.sleep(60)
    
    # Verify file exists
    print(f"\nğŸ” Checking if file exists: {file_path}")
    info = fs.get_file_info(file_path)
    if not info.success:
        pytest.fail(f"File not found at {file_path}. Please ensure the file is uploaded correctly.")
    
    file_size = int(info.file_info["size"])
    print(f"âœ… File found, size: {file_size} bytes")
    
    # Read binary file using format='bytes'
    print(f"\nğŸ“– Reading binary file: {file_path}")
    result = fs.read_file(file_path, format="bytes")
    assert result.success, f"Failed to read binary file: {result.error_message}"
    assert isinstance(result, BinaryFileContentResult), "Result should be BinaryFileContentResult"
    assert isinstance(result.content, bytes), "Content should be bytes type"
    assert len(result.content) == file_size, f"Expected {file_size} bytes, got {len(result.content)}"
    
    # Verify it's a JPEG file by checking file header
    # JPEG files start with FF D8 FF
    if len(result.content) >= 3:
        jpeg_header = result.content[:3]
        assert jpeg_header == b'\xff\xd8\xff', f"File does not appear to be a JPEG (header: {jpeg_header.hex()})"
        print(f"âœ… JPEG header verified: {jpeg_header.hex()}")
    else:
        print(f"âš ï¸  File too small to verify JPEG header (size: {len(result.content)} bytes)")
    
    print(f"âœ… Successfully read JPEG file: {len(result.content)} bytes")
    
    # Save the read image to local file for verification
    import tempfile
    from pathlib import Path
    
    # Create a temporary file to save the image
    temp_dir = tempfile.gettempdir()
    local_image_path = os.path.join(temp_dir, "test_read_image.jpeg")
    
    print(f"\nğŸ’¾ Saving read image to local file for verification...")
    print(f"   Local path: {local_image_path}")
    
    with open(local_image_path, 'wb') as f:
        f.write(result.content)
    
    # Verify local file was saved correctly
    local_file_size = os.path.getsize(local_image_path)
    assert local_file_size == len(result.content), f"Local file size mismatch: {local_file_size} vs {len(result.content)}"
    
    print(f"âœ… Image saved successfully to: {local_image_path}")
    print(f"   File size: {local_file_size} bytes")
    print(f"\nğŸ–¼ï¸  You can now open this image file to verify the content:")
    print(f"   open {local_image_path}")
    
    # Additional verification: check file tail (JPEG files end with FF D9)
    if len(result.content) >= 2:
        jpeg_tail = result.content[-2:]
        if jpeg_tail == b'\xff\xd9':
            print(f"âœ… JPEG file tail verified: {jpeg_tail.hex()}")
        else:
            print(f"âš ï¸  JPEG file tail unexpected: {jpeg_tail.hex()} (expected: ffd9)")
    
    # Verify optional fields
    if result.size is not None:
        assert result.size == file_size
    
    print(f"\nâœ… Binary file read test completed successfully!")
    print(f"ğŸ“ Local verification file: {local_image_path}")


@pytest.mark.sync
def test_read_binary_file_with_non_zero_content(test_session):
    """Test reading a binary file with non-zero content."""
    cmd = test_session.command
    fs = test_session.file_system

    # Create binary file with pattern (using printf to create specific bytes)
    # Create a file with pattern: 0x00, 0x01, 0x02, ... repeating
    create_result = cmd.execute_command(
        "python3 -c \"with open('/tmp/binary_pattern_test', 'wb') as f: f.write(bytes(range(256)) * 4)\""
    )
    assert create_result.success

    # Read binary file
    result = fs.read_file("/tmp/binary_pattern_test", format="bytes")
    assert result.success, f"Failed to read binary file: {result.error_message}"
    assert isinstance(result, BinaryFileContentResult)
    assert isinstance(result.content, bytes)
    
    # Verify content pattern (0-255 repeating 4 times = 1024 bytes)
    expected_pattern = bytes(range(256)) * 4
    assert len(result.content) == len(expected_pattern)
    assert result.content == expected_pattern
    
    print(f"Successfully read binary file with pattern: {len(result.content)} bytes")


@pytest.mark.sync
def test_read_text_file_still_works(test_session):
    """Test that reading text files still works with default format."""
    fs = test_session.file_system

    test_content = "This is a test text file for binary read feature."
    test_file_path = "/tmp/test_text_for_binary_feature.txt"

    # Write text file
    write_result = fs.write_file(test_file_path, test_content, "overwrite")
    assert write_result.success

    # Read as text (default format)
    result = fs.read_file(test_file_path)
    assert result.success
    assert result.content == test_content
    assert isinstance(result.content, str)
    
    # Explicitly read as text format
    result_explicit = fs.read_file(test_file_path, format="text")
    assert result_explicit.success
    assert result_explicit.content == test_content
    assert isinstance(result_explicit.content, str)
    
    print("Text file reading still works correctly")
